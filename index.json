[{"content":"","date":"28 июля 2024","externalUrl":null,"permalink":"/tags/chezmoi/","section":"Tags","summary":"","title":"Chezmoi","type":"tags"},{"content":"","date":"28 июля 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"28 июля 2024","externalUrl":null,"permalink":"/tags/ssh/","section":"Tags","summary":"","title":"SSH","type":"tags"},{"content":" Преамбула # Наверное всего того, что описано ниже не было, если бы я придерживался хоть какого-то work-life balance. А пока - мне нужен доступ к серверам, часто в любое время, в любом месте. Речь не о том что бы программировать с телефона (хотя в качестве примера это, пожалуй, тоже рассмотрим), а скорее перезапустить какую-нибудь службу, или убить зависший процесс. В прочем, обо всём по порядку.\nШаринг доступов SSH # Путь # За время работы в разных компаниях, я видел разные способы шаринга доступов к серверам. У кого-то это были гугл таблицы с логинами и паролями, у кого-то самописные шифровальщики паролей. Мы долгое время использовали passbolt (что хоть и решало проблему, но только частично). В целом, на рабочих серверах большому числу людей делать нечего. Те же разработчики по идее выливают изменения через CI/CD. Но даже если у вас всего один системный администратор, хотелось бы:\nИметь одинаковые учётные записи на всех серверах (при чём отдельные под каждого пользователя) Доступ осуществлялся через ключи Данные о ip адресах и портах не приходилось тягать вручуную Как результат, мы пришли к следующей модели:\nСоздаём группу по названию компании (ansible) Создаём пользователей, прописываем их ключи и добавляем в группу (ansible) Проверяем есть ли в группе пользователи вне списка, их удаляем (например при увольнении) (ansible) Записываем хост в конфиг chezmoi и шарим по машинам Описывать часть Ansible я не буду, так как наше решение всё ещё не идеальное, оно скорее закрывало наши боли в моменте. А вот chezmoi интересный инструмент, который я опишу ниже.\nChezmoi # Не зависимо от того на какой платформе вы работете, ваш ssh конфиг хранятся в ~/.ssh/. Более того, формат для linux и windows - одинаковый. Теоретически - можно хранить свежую версию config файла в git, и это закроет большую часть потребностей. Но позже, хочется:\nРазделить ssh ключи на группы Иметь возможность подмены всяких переменных Тут то мне и попался на глаза chezmoi.\nЭтап 1. Файл инициализации. # Вы можете определить файл который интерактивно запросит глобальные переменные у пользователя при инициализации. У меня это было что-то типа:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{- writeToStdout \u0026#34;Добро пожаловать в мастер конфигурации\\n\u0026#34; -}} {{- writeToStdout \u0026#34;❗️Для повторной инициализации имени полльзователя используйте флаг --data=false\\n\u0026#34; -}} {{- /* Ввод пользователя {n} серверов */ -}} {{- $d_server_user := promptStringOnce . \u0026#34;d_server_user\u0026#34; \u0026#34;Введите имя пользователя для внутренних серверов:\u0026#34; -}} {{- if $d_server_user -}} {{- writeToStdout (printf \u0026#34;✅ Будем использовать имя \u0026#39;%s\u0026#39; для авторизации на внутренних серверах\\n\u0026#34; $d_server_user) -}} {{- else -}} {{- writeToStdout \u0026#34;❌ Имя пользователя .. не указано\\n\u0026#34; -}} {{- end -}} {{- /* Ниже ещё несколько вопросов, например касательно групп подключаемых серверов */ -}} Теперь при первом запуске инициализации chezmoi запросит базовые переменные.\nЭтап 2. Создание шаблона # Не хочется сводить статью к цитированию документации. Я не уверен что статья не устарела на тот момент как я её опубликовал. Но основную мысль передам. Chezmoi использует шаблонизатор go. Если вы с ним не знакомы - это не проблема, в документации есть множество примеров.\n1 2 3 4 5 6 7 8 #SHARED CONFIG REGION START {{ if .otherEnable -}} Host ТутНазваниеХоста HostName тутIpАдресИлиДомен ProxyCommand ssh -W %h:%p ТоЧерезЧтоПроксируем User {{.d_server_user}} Port 62626 {{end}} В целом стандартная структура файла .ssh, за исключением\n{{ if .otherEnable -}} \u0026hellip; {{end}} - Условный блок, что означает что сервер не будет включён в файл у тех пользоветелей, которые указали что им доступ на сервера other не нужны. {{.d_server_user}} - наша переменная То есть ключ пользователя добавлен на сервер под его учётной записью (чаще всего фамилия.ио). А сами параметры подключени пользователь получает через chezmoi.\nЭтап 3. Подключение полученного файла. # Этот этап на первых парах вызвал некоторые проблемы, так как не хотелось получать ошибку совместимости файлов, после того как пользователь допишет своих параметров в ssh. Однако было найдено простое решение. Конфигурацию ssh, мы прописываем не в файл ~/.ssh/config а рядом в ~/.ssh/share_config. И подключаем скриптом (run_apply.sh):\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/bin/sh stringSearch=\u0026#39;include shared_config\u0026#39;; if [ -f ~/.ssh/config ]; then if grep -q \u0026#34;$stringSearch\u0026#34; ~/.ssh/config; then echo \u0026#34;✅ Includ уже прописан в вашем ~/.ssh/config\u0026#34;; else sed -i \u0026#34;1s/^/$stringSearch\\n/\u0026#34; ~/.ssh/config; echo \u0026#34;❗️ Includ прописал в вашем ~/.ssh/config\u0026#34;; fi else echo \u0026#34;$stringSearch\u0026#34; \u0026gt; ~/.ssh/config echo \u0026#34;❗️ Создал ~/.ssh/config\u0026#34;; fi Как только появился скрипт sh - сразу возник вопрос совместимости с windows. И пришлось добавить следующие строки в .chezmoi.json.tmpl:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;data\u0026#34;:{ ... }, \u0026#34;interpreters\u0026#34;:{ \u0026#34;sh\u0026#34;:{ {{- if eq .chezmoi.os \u0026#34;linux\u0026#34; -}} \u0026#34;command\u0026#34;:\u0026#34;bash\u0026#34; {{- if eq .chezmoi.os \u0026#34;android\u0026#34; -}} \u0026#34;command\u0026#34;:\u0026#34;bash\u0026#34; {{- else -}} \u0026#34;command\u0026#34;:\u0026#34;C:\\\\Program Files\\\\Git\\\\bin\\\\sh.exe\u0026#34; {{- end -}} } } } Теперь, при применении конфигурации chezmoi запускает скрипт, который пытается прописать include shared_config в файл ~/.ssh/conf.\nЦикл работы # При появлении нового сервера/либо сотрудника прогоняем ansible по серверам создавая пользователей и добавляя им ключи Сотрудник устанавливает chezmoi и пишет в консоли chezmoi init. Ответив интерактивно на вопросы - уже может подключаться к любому доступному серверу. (список доступных серверов виден в файле). Если вы ранее не работали с ~/.ssh/conf, то для вас будет приятный бонус, так как для подключения к серверу теперь вместо ssh root@myserver.ru -p 242321 достаточно ввести ssh myserver.ru. Сотрудник увольняется. Мы так же прогоняем ansible по серверам, и он удаляет пользователя. Повторюсь. У этой системы есть недостатки, но это закрывает базовые потребности, без необходимости завозить полноценный ldap.\nПри чём здесь телефон. # Теперь, имея способ шаринга доступов, можно шарить их везде. Например на телефоне (если у вас не айфон, конечно)\nУстанавливаем termux. Тут нет никаких подводных камней. Он доступен в маркете, но важно!, устанавливать его из f-droid. Если установить termux из маркета, то дополнения будут платными. Если установить термукс из маркета, а дополнения из fdroid - будут конфликтовать. Сразу можно установить termux: Далее - мой путь (не гайдлайн).\nЧто бы избежать возможных проблем pkg update и pkg upgrade Устанавливаем zsh, git, curl, wget pkg install zsh git curl wget 1.1. Вам может понадобится vim. Я использую AstroVim.\npkg install neovim git clone --depth 1 https://github.com/AstroNvim/template ~/.config/nvim rm -rf ~/.config/nvim/.git #Почему-то когда я писал статью, не подтянул в зависимости си. Установим вручную pkg install clang zig Устанавливаем ohmyzsh sh -c \u0026#34;$(curl -fsSL https://install.ohmyz.sh/)\u0026#34; Используем zsh по умолчанию chsh -s zsh В зависимости от темы могут понадобится дополнительные шрифты. Об этом описано на странице zsh. Обычно, это сводится к клонированию репозитория, и запуска установочного install.sh. Перед установкой стоит попробовать выбрать шрифт через стилизацию (долгий тап - More - Style). Тут же меняется цвет фона. 4. Наконец установка самого chezmoi\npkg install chezmoi Инициализация вашей конфигурации: chezmoi init ссылка_на_ваш_репозиторий Дичь (я попытаюсь добавить её в каждой статье) # Верстать адаптив сразу на телефоне # Термукс по сути позволяет запустить node js. Vue из под vite не завёлся ругаясь на компилятор eslint`а (кажется это мелкая устранимая проблема, но честно говоря\u0026hellip;) А вот проект на vue2 завёлся без проблем. Открыв вторую вкладку термукса, можно править файлы и даже watch отрабатывает корректно. Смотреть результат можно тут же в окне браузера:\nСидеть в интернете через консольный браузер # Я попробовал установить browsh, но он отказался запускаться (не видел firefox). А вот lynx запустился. Вот, например, этот блог:\nШалость не удалась # В максимальном угаре хотелось запустить докер, и в нём какую-то весомую серверную часть. Судя по гайдлайнам в интернетах это возможно, но подразумевает что через qemu будет поднят образ alpine, и уже в нём докер. Я честно говоря не настолько упорот в данный момент. Возможно когда-нибудь.\n","date":"28 июля 2024","externalUrl":null,"permalink":"/posts/mobile-ssh/","section":"Posts","summary":"Преамбула # Наверное всего того, что описано ниже не было, если бы я придерживался хоть какого-то work-life balance. А пока - мне нужен доступ к серверам, часто в любое время, в любом месте. Речь не о том что бы программировать с телефона (хотя в качестве примера это, пожалуй, тоже рассмотрим), а скорее перезапустить какую-нибудь службу, или убить зависший процесс.","title":"SSH с мобильного. Мой путь.","type":"posts"},{"content":"","date":"28 июля 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"28 июля 2024","externalUrl":null,"permalink":"/tags/termux/","section":"Tags","summary":"","title":"Termux","type":"tags"},{"content":" ","date":"28 июля 2024","externalUrl":null,"permalink":"/","section":"Welcome to elektronnyj bloG! 🎉","summary":" ","title":"Welcome to elektronnyj bloG! 🎉","type":"page"},{"content":"","date":"3 июня 2024","externalUrl":null,"permalink":"/tags/bitrix24/","section":"Tags","summary":"","title":"Bitrix24","type":"tags"},{"content":" Disclaimer # Описанное ниже, не является руководством к действию, не испытано на практике и по сути является лишь демонстрацией возможностей облачных порталов Bitrix24.\nЭтот проект задумывался ещё когда порталы Bitrix24 с бесплатным тарифом позволяли использовать REST api.\nИдея # Задумка следующая. В bitrix24 есть механизм PushAndPull (по сути это обычный websocket). Он используется для работы мессенджера, обновления данных в карточках \u0026ldquo;на лету\u0026rdquo; и обмена с 1с \u0026ldquo;в режиме реального времени\u0026rdquo;.\nКасательно 1с - это скорее ухищрение, к которому прибегли из-за того, что не каждую 1с есть возможность открыть наружу (да и не все хотят). Поэтому происходит следующее:\nВ качестве токена доступа мы вводим refresh_token (тот код что просит ввести обмен 1с) По этому токену 1с получает данные домена (обращаясь к серверу авторизации битрикс) По полученным авторизационным данным - получаем параметры подключения к веб-сокету Слушаем сообщения в реальном времени Так вот, что если, проделать тот же путь что и 1с, но в конечном итоге слушать не события битрикса для их обновления, а например, управлять устройствами умного дома?\nПовторюсь. Идея бредовая. Не делайте умный дом на битрикс24. Пожалуйста. Нам понадобится: # Модуль с wi-fi на борту. Я взял esp-8266 (просто потому что попался первым под руку) Реле (так же выбирал из того что было) Транзистор (не хватало мощности клацать напрямую реле, поэтому IRF-3205) Кнопка Клемма 3 светодиода Всё это было собрано на макетной плате, в черновом виде, просто потому что изначально задумывалось как шалость. Приводить схему соединения всего этого не буду, по сути транзистор подключен к выводу D6, и управляет реле. Кнопка задумывалась как сброс настроек (для включения в режиме точки доступа). Остальное ниже - по коду.\nКод # Функция setup инициализирует пины, устанавливает callBack-функции веб-сокета (их рассмотрим ниже) и пробует считать из энергонезависимой памяти данные подключения к wi-fi и битрикс 24. Если зажата кнопка (которую мы подключили на вывод D7) - то эти параметры игнорируются и стартует сервер.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void setup() { // ----- ТУТ был код инициализации пинов ------ int valueButton=digitalRead(BTN_PIN); //установка callback функций webSocketClient.onMessage(onMessageCallback); webSocketClient.onEvent(onEventsCallback); //по умолчанию реле выключено digitalWrite(RELE_PIN, LOW); delay(500); //храним в том же порядке ssid, pass, refresh, device ssid=readStringFromEEPROM(0, SSID_LENGTH); Serial.println(\u0026#34;ssid:\\\u0026#34;\u0026#34;+ssid+\u0026#34;\\\u0026#34;\u0026#34;); //Если кнопка не нажата и ssid заполнен if (!valueButton\u0026amp;\u0026amp;!ssid.isEmpty()){ password=readStringFromEEPROM(SSID_LENGTH, PASS_LENGTH); refresh_token=readStringFromEEPROM(PASS_LENGTH, REFRESH_LENGTH); deviceName=readStringFromEEPROM(REFRESH_LENGTH, DEVICE_LENGTH); } else{// Иначе - запускаем в режиме точки доступа startServer(); serverStarted=true; } } Главный цикл программы. Проверяем подключены ли мы к wi-fi, если нет - проверяем запущен ли контроллер в режиме точки доступа, если нет - пытаемся подключиться к wi-fi.\n1 2 3 4 5 6 7 8 9 10 11 12 void loop(){ if (WiFi.status() == WL_CONNECTED) { webSocketClient.poll(); } else{ if (serverStarted) server.handleClient(); else{ tryConnectToWifi(); } } } Так как при первом включении ssid будет пустым, сразу рассмотрим что из себя представляет функция startServer и handleClient:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void startServer(){//Стандартная функция точки доступа из примеров // Запуск собственной точки доступа (Access Point) WiFi.mode(WIFI_AP); WiFi.softAP(apSsid, apPassword); delay(100); // Небольшая задержка для установки соединения server.on(\u0026#34;/\u0026#34;, handleRoot); server.begin(); delay(500); Serial.println(WiFi.softAPIP()); } void handleRoot(){ if(server.method()==HTTP_POST){//Если пост - сохраняем параметры, иначе - отдаём страничку настроек handleSave(); } else{ sendPage(); } } void sendPage(){//Отправляет страничку в виде String html = \u0026#34;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;body style=\\\u0026#34;background: #03a9f4; color: #fff; font-family: sans-serif;\\\u0026#34;\u0026gt;\u0026#34;; //---------- Тут ещё десяток таких же красивых строк ---------- html += \u0026#34;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; server.send(200, \u0026#34;text/html\u0026#34;, html); } void handleSave(){ ssid = server.arg(\u0026#34;ssid\u0026#34;); password = server.arg(\u0026#34;password\u0026#34;); refresh_token = server.arg(\u0026#34;refresh_token\u0026#34;); deviceName = server.arg(\u0026#34;deviceName\u0026#34;); writeStringToEEPROM(REFRESH_LENGTH, deviceName); String html = \u0026#34;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;meta charset=\u0026#39;utf-8\u0026#39;\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;meta name=\u0026#39;viewport\u0026#39; content=\u0026#39;width=device-width, initial-scale=1\u0026#39;\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;/head\u0026gt;\u0026#34;; html += \u0026#34;\u0026lt;body\u0026gt;Настройки сохранены\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; server.send(200, \u0026#34;text/plain\u0026#34;, html); serverStarted=false; } После сохранения параметров микроконтроллер попробует подключиться к wi-fi. Функция вцелом стандартная, так же взята из примеров работы с wi-fi модулем. С разницей лишь в том, что после 10 секунд, если не получилось подключиться к wi-fi, снова стартует режим точки доступа для изменения настроек. Если подключиться удалось - обновляем refresh токен.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 void tryConnectToWifi(){ serverStarted=false; WiFi.mode(WIFI_STA); WiFi.begin(ssid, password); int i=0; while (WiFi.status() != WL_CONNECTED) { Serial.println(\u0026#34;Подключение к Wi-Fi...\u0026#34;+\u0026#39; \u0026#39;+ssid+\u0026#39; \u0026#39;+password); i++; delay(1000); if (i\u0026gt;=10){ startServer(); serverStarted=true; return; } } //Если подключились - сохраняем параметры wifi writeStringToEEPROM(0, ssid); writeStringToEEPROM(SSID_LENGTH, password); //Включаем первый светодиод digitalWrite(LED1_PIN, HIGH); //Обновляем refresh_token refreshAndConnect(); } void refreshAndConnect(){ delay(500); ResultRefresh result=refreshToken(refresh_token); if (result.access_token.isEmpty()||result.refresh_token.isEmpty()){ startServer(); serverStarted=true; return; } refresh_token=result.refresh_token; writeStringToEEPROM(PASS_LENGTH, refresh_token); client_endpoint=result.client_endpoint; access_token=result.access_token; SocketParams socketParams=getSocketParams(client_endpoint, access_token); webSocketClient.setInsecure(); webSocketClient.ping(); webSocketClient.connect(socketParams.server+\u0026#34;?CHANNEL_ID=\u0026#34;+socketParams.chanel+\u0026#34;\u0026amp;clientId=\u0026#34;+getClientId()); } Выше я не описываю refreshToken и getSocketParams, так как это типовые вызовы rest, но очень объёмные. refreshToken - делает обращение к https://oauth.bitrix.info/oauth/token/?grant_type=refresh_token getSocketParams - делает обращение к https://{ваш портал}//rest/pull.application.config.get\nИ последнее - две callback функции.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void onMessageCallback(WebsocketsMessage message) { String bodyRaw=message.data(); bodyRaw.replace(\u0026#34;#!NGINXNMS!#\u0026#34;, \u0026#34;\u0026#34;); bodyRaw.replace(\u0026#34;#!NGINXNME!#\u0026#34;, \u0026#34;\u0026#34;); Serial.println(bodyRaw); DynamicJsonDocument doc(2024); DeserializationError error = deserializeJson(doc, bodyRaw); if (error) { Serial.print(\u0026#34;Ошибка разбора JSON: \u0026#34;); Serial.println(error.c_str()); } else{ // Доступ к значениям JSON String command=doc[\u0026#34;text\u0026#34;][\u0026#34;command\u0026#34;].as\u0026lt;String\u0026gt;(); if (command==\u0026#34;esp\u0026#34;){ String device=doc[\u0026#34;text\u0026#34;][\u0026#34;params\u0026#34;][\u0026#34;device\u0026#34;].as\u0026lt;String\u0026gt;(); if (device==deviceName||deviceName.isEmpty()){ String value=doc[\u0026#34;text\u0026#34;][\u0026#34;params\u0026#34;][\u0026#34;value\u0026#34;].as\u0026lt;String\u0026gt;(); if(value==\u0026#34;1\u0026#34;){ digitalWrite(RELE_PIN, HIGH); } else{ digitalWrite(RELE_PIN, LOW); } Serial.println(\u0026#34;Message params: \u0026#34;+command+\u0026#34; device: \u0026#34;+device+\u0026#34; value: \u0026#34;+value); } } Serial.println(\u0026#34;Input message\u0026#34;); digitalWrite(LED5_PIN, HIGH); delay(1000); digitalWrite(LED5_PIN, LOW); } } void onEventsCallback(WebsocketsEvent event, String data) { if(event == WebsocketsEvent::ConnectionOpened) { digitalWrite(LED3_PIN, HIGH); Serial.println(\u0026#34;Connnection Opened\u0026#34;); } else if(event == WebsocketsEvent::ConnectionClosed) { refreshAndConnect(); } else if(event == WebsocketsEvent::GotPing) { Serial.println(\u0026#34;Got a Ping!\u0026#34;); } else if(event == WebsocketsEvent::GotPong) { Serial.println(\u0026#34;Got a Pong!\u0026#34;); } } То есть при подключении загорается светодиод подключенный к D3. При получении сообщения отрабатывает функция, которая пробует разобрать json, и если команда и id устройства (в случае если их несколько) совпадает - переключить на значение value реле.\nЗапуск и тестирование # Первое включение # При первом запуске появляется страничка настройки где необходимо ввести параметры подключения к wi-fi и refresh_token приложения.\nПосле сохранения настроек, микроконтроллер должен перезагрузится (телефон сам отключится от точки доступа), а на плате по очереди загорится первый (успешно подключились к wi-fi) и второй (успешно подключились к битриксу) светодиоды.\nДалее, в качестве теста нам необходимо переключиться в окно приложения и отправить следующую команду:\nBX24.callMethod(\u0026#39;pull.application.event.add\u0026#39;, { \u0026#39;COMMAND\u0026#39;: \u0026#39;esp\u0026#39;, \u0026#39;PARAMS\u0026#39;: \u0026#39;{\u0026#34;value\u0026#34;:\u0026#34;1\u0026#34;}\u0026#39;, }, function(result){ console.log(result); }); На каждое сообщение на 1 секунду загорается синий светодиод. При изменении значения в поле value - получаем получаем соответствующее логическое значение нагрузки.\nПодключение нагрузки # В идеале к нагрузке было бы подключить лампочку, у неё и ток больше чем у зарадки, и выглядит нагляднее, но лампочки под рукой не нашлось. Больше дичи # Так как управление нагрузкой теперь работает в рамках Битрикс24, управлять нагрузкой мы можем через бизнес процесс. Например:\nТо есть, мы можем включать нагрузку при наступлении каких-то условий в бп. Например, при создании лида, мы можем засечь час времени, и через час повторно проверить статус лида. Если статус не был изменён, включать нагрузку для физического воздействия на менеджера.\nНа этом всё. Кто осилил - тот умничка.\n","date":"3 июня 2024","externalUrl":null,"permalink":"/posts/bitrix-cloud-part-1/","section":"Posts","summary":"Disclaimer # Описанное ниже, не является руководством к действию, не испытано на практике и по сути является лишь демонстрацией возможностей облачных порталов Bitrix24.\nЭтот проект задумывался ещё когда порталы Bitrix24 с бесплатным тарифом позволяли использовать REST api.\nИдея # Задумка следующая. В bitrix24 есть механизм PushAndPull (по сути это обычный websocket).","title":"Bitrix24 - облако не приговор (часть 1)","type":"posts"},{"content":"","date":"3 июня 2024","externalUrl":null,"permalink":"/tags/esp/","section":"Tags","summary":"","title":"Esp","type":"tags"},{"content":"","date":"3 июня 2024","externalUrl":null,"permalink":"/tags/%D0%BE%D0%B1%D0%BB%D0%B0%D0%BA%D0%BE/","section":"Tags","summary":"","title":"Облако","type":"tags"},{"content":"","date":"3 июня 2024","externalUrl":null,"permalink":"/tags/%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B/","section":"Tags","summary":"","title":"Эксперементы","type":"tags"}]